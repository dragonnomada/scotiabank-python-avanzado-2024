# -*- coding: utf-8 -*-
"""scotiabank-python-avanzado-modulo-01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sQFA9_jjyClqOFoTxjV7yU5BkLwpXfo-

# Curso de Python Avanzado

<img src="https://amei.mx/wp-content/uploads/2016/08/Scotiabank-logo.jpg" alt="Scotiabank Logo" height="60">
<img src="https://www.belatrix.com/wp-content/uploads/2023/08/belatrix-logosweb-1.png" alt="Belatrix Logo" height="60">


**[Scotiabank](https://www.scotiabank.com.mx)** | **[Belatrix](https://www.belatrix.com)**

Instructor: [Alan Badillo Salas](alan@nomadacode.com)

## Bienvenida

Bienvenidos al curso de **Python Avanzado** para Scotiabank, brindado por Belatrix.

En este curso aprender谩s a desarrollar una programaci贸n avanzada con Python.

El curso est谩 dirigido a profesionales relacionados al 谩rea de desarrollo, soporte y an谩lisis de datos.

Se requieren conocimientos previos de Python Intermedio para poder cubrir satisfactoriamente este curso.

## Temario

**M贸dulo 1: Programaci贸n Funcional en Python**

1. Introducci贸n a la programaci贸n funcional
2. Funciones de orden superior
3. Lambdas y expresiones generadoras

**M贸dulo 2: Dise帽o de Patrones Avanzados**

1. Patrones de dise帽o comunes en Python
2. Aplicaci贸n pr谩ctica de patrones en el desarrollo de software

**M贸dulo 3: Manipulaci贸n Eficiente de Datos**

1. Uso avanzado de NumPy y Pandas
2. Operaciones vectorizadas y broadcasting

**M贸dulo 4: Concurrencia y Paralelismo en Python**

1. Hilos y procesos en Python
2. Multiprocessing y Asyncio

**M贸dulo 5: Optimizaci贸n de C贸digo**

1. Estrategias para mejorar el rendimiento
2. Perfilado de c贸digo y herramientas de optimizaci贸n

**M贸dulo 6: Seguridad en Desarrollo Python**

1. Principios b谩sicos de seguridad
2. Mejores pr谩cticas de codificaci贸n segura

**M贸dulo 7: Despliegue y Escalabilidad**

1. Configuraci贸n de entornos de producci贸n
2. Estrategias para escalabilidad horizontal y vertical

## Repaso General de Python
"""

# Variables de tipos primitivos

nombre = "Daniela" # str
apellidos = 'Gonz谩lez Mart铆nez' # str
edad = 23 # int
peso = 54.6 # float
frecuencia = 43.5 + 2.3j # complex
casado = True # bool
trabajo = False # bool

print(f"NOMBRE: {nombre} {apellidos}")
print(f"EDAD: {edad} a帽os | PESO: {peso} kg")
print(f"CASADO: {casado} | TRABAJO: {trabajo}")

print("NOMBRE: {} {}".format(nombre, apellidos))
print("EDAD: {:4} a帽os | PESO: {:>10} kg".format(edad, peso))
bool_to_text = lambda p: "SI" if p else "NO"
print("CASADO: {:>7} | TRABAJO: {:>10}".format(bool_to_text(casado), bool_to_text(trabajo)))

# Colecciones: listas, tuplas, diccionarios

# Listas -> Conjunto secuencial, indexado de valores din谩micos

frutas = ["pera", "manzana", "pi帽a"]

print(frutas)
print(frutas[1]) # 0 - pera, 1 - manzana, 2 - pi帽a

frutas.append("pl谩tano")

print(frutas)

frutas.insert(0, "mel贸n")

print(frutas)

frutas.pop(2) # 2 - manzana

print(frutas)

print(frutas[2:4]) # ["pi帽a", "pl谩tano"]

print(frutas[0::2]) # ["mel贸n", "pi帽a"]

# Tuplas -> Conjunto secuencial, indexado de valores fijos

nombre = "Daniel"
salario = 10_500

datos_daniel = (nombre, salario) # <2-tupla> (<valor 1>, <valor 2>)

print(datos_daniel)

n, s = datos_daniel # Desacomplar la <2-tupla> en 2-variables

print(n) # "Daniel"
print(s) # "salario"

t = (8, "Daniel", 23, True, False) # Es complejo determinar a qu茅 se refiere cada posici贸n (铆ndice)

id, nombre, edad, casado, trabajo = t # Es complejo recordar cada variable acoplada

# Diccionarios -> Conjunto no secuencial, indexado de valores din谩micos

# Equivale a un "FRAME" de informaci贸n
d = {
    "id": 8,
    "nombre": "Daniel",
    "edad": 23,
    "casado": True,
    "trabajo": False
}

print(d)

print(d["nombre"]) # "Daniel"
print(d["edad"]) # 23
print(d["trabajo"]) # False

"""# M贸dulo 1: Programaci贸n Funcional en Python

1. Introducci贸n a la programaci贸n funcional
2. Funciones de orden superior
3. Lambdas y expresiones generadoras

## 101. Introducci贸n a la programaci贸n funcional

La programaci贸n funcional es un paradigma de programaci贸n que trata a la computaci贸n como la evaluaci贸n de funciones matem谩ticas y evita cambiar el estado y los datos mutables. Es distinta de la programaci贸n imperativa, que enfoca la computaci贸n en t茅rminos de instrucciones que cambian el estado del programa. La programaci贸n funcional ofrece varios beneficios, como la facilidad de pruebas y depuraci贸n, debido a que las funciones puras (un concepto clave en este paradigma) siempre producen el mismo resultado para los mismos argumentos y no tienen efectos secundarios (como modificar variables globales o el estado del sistema).

Aqu铆 hay algunos conceptos clave en la programaci贸n funcional:

### 1. **Funciones Puras**
   - Son funciones donde el resultado solo depende de los argumentos proporcionados y no producen efectos secundarios (como modificar variables externas). Esto facilita entender y predecir el comportamiento del c贸digo.

### 2. **Inmutabilidad**
   - Los datos nunca cambian despu茅s de su creaci贸n. Si quieres modificar un objeto, debes crear uno nuevo con los cambios deseados. Esto previene efectos secundarios no deseados y hace que el c贸digo sea m谩s seguro y f谩cil de razonar.

### 3. **Funciones de Orden Superior**
   - Son funciones que toman otras funciones como argumentos o las devuelven como resultado. Esto permite t茅cnicas como la composici贸n de funciones, donde se combinan varias funciones peque帽as para crear una nueva funci贸n.

### 4. **Expresiones Lambda**
   - Son una forma de crear funciones an贸nimas en el momento, lo que es 煤til para operaciones cortas que no requieren la definici贸n de una funci贸n nombrada completa.

### 5. **Evaluaci贸n Perezosa**
   - Significa que la evaluaci贸n de una expresi贸n se retrasa hasta que su resultado sea realmente necesario. Esto puede mejorar el rendimiento al evitar c谩lculos innecesarios y permite estructuras de datos infinitas, como listas infinitas.

### 6. **Recursividad**
   - Dado que la inmutabilidad proh铆be las variables que cambian, la recursividad se utiliza a menudo en lugar de ciclos tradicionales como bucles for o while. La recursividad implica que una funci贸n se llame a s铆 misma dentro de su definici贸n.

### 7. **Patrones Comunes**
   - Mapa, filtro y reducci贸n son patrones de dise帽o comunes en la programaci贸n funcional que operan en listas o secuencias de datos. Permiten la transformaci贸n, selecci贸n y agregaci贸n de datos de manera expresiva y concisa.

### Ejemplo B谩sico en Python

Python no es un lenguaje de programaci贸n puramente funcional, pero admite muchos conceptos de programaci贸n funcional. Aqu铆 hay un ejemplo simple que muestra el uso de funciones puras y la inmutabilidad:

```python
# Funci贸n pura
def sumar(a, b):
    return a + b

# Uso de funciones de orden superior y expresiones lambda
numeros = [1, 2, 3, 4, 5]
numeros_cuadrados = list(map(lambda x: x**2, numeros))

# La lista original permanece inalterada, demostrando inmutabilidad
print(numeros)  # [1, 2, 3, 4, 5]
print(numeros_cuadrados)  # [1, 4, 9, 16, 25]
```

Este ejemplo ilustra c贸mo la programaci贸n funcional puede ser utilizada en Python para escribir c贸digo conciso y mantenible.
"""

# Ejemplos 101

def suma(a, b):
  return a + b

suma(5, 6)

suma(1000, 2000)

suma("Hola", "mundo")

def concatenar(*valores): # Todos los par谩metros los acumula en una lista
  buffer = ""
  for valor in valores:
    buffer += valor
  return buffer

concatenar("Hola", " ", "mundo", " ", "")

def calcular_tama帽o(textos): # Definici贸n de la funci贸n
  # textos = ["manzana", "pera", ...]

  # Necesitamos una lista nueva originalmente vac铆a
  # para guardar los tama帽os de cada uno de los textos
  tama帽os = []

  # Si textos es una lista de valores de texto,
  # entonces, podemos iterar cada uno de esos valores
  # y cada uno representar谩 un texto
  for texto in textos:
    # Inspeccionamos cada texto y su tama帽o en cada iteraci贸n
    #print(texto, len(texto))
    # Necesitamos almacenar el tama帽o del texto a una lista (agregaci贸n)
    tama帽os.append(len(texto))

  #print(tama帽os)

  return tama帽os

frutas = ["manzana", "pera", "mango", "lim贸n", "guanabana", "kiwi"]

calcular_tama帽o(frutas) # Llamada a la funci贸n

frutas = ["manzana", "pera", "mango", "lim贸n", "guanabana", "kiwi"]
tama帽os = calcular_tama帽o(frutas)

print(frutas)
print(tama帽os)

list(zip(frutas, tama帽os)) # relaci贸n 1-1 entre frutas y tama帽os

dict(zip(frutas, tama帽os))

# Adaptador no gen茅rico
def calcular_tama帽o_con_info(textos): # Definici贸n de la funci贸n
  tama帽os = []

  for texto in textos:
    tama帽os.append({
        "texto": texto,
        "tama帽o": len(texto),
        "inicial": texto[0],
        "terminal": texto[-1],
    })

  return tama帽os

frutas = ["manzana", "pera", "mango", "lim贸n", "guanabana", "kiwi"]

calcular_tama帽o_con_info(frutas) # Llamada a la funci贸n

"""## 102. Funciones de orden superior

Las funciones de orden superior son un concepto fundamental en la programaci贸n funcional, que permite una programaci贸n m谩s expresiva y flexible. En Python, as铆 como en otros lenguajes que soportan paradigmas de programaci贸n funcional, estas funciones son herramientas poderosas que facilitan la escritura de c贸digo conciso, legible y eficiente.

### Definici贸n

Una funci贸n de orden superior es una funci贸n que cumple al menos uno de los siguientes criterios:

- Toma una o m谩s funciones como argumentos.
- Devuelve otra funci贸n como su resultado.

Este concepto permite abstracciones funcionales y operaciones que pueden reducir significativamente la redundancia en el c贸digo y mejorar su modularidad.

### Ejemplos de Funciones de Orden Superior en Python

Python ofrece varias funciones incorporadas que son ejemplos de funciones de orden superior. Algunas de las m谩s utilizadas incluyen `map()`, `filter()`, y `reduce()`.

#### `map(function, iterable, ...)`

- **Prop贸sito**: Aplica una funci贸n dada a cada elemento de un iterable (lista, tupla, etc.) y devuelve un iterador que produce los resultados.
- **Ejemplo**:

```python
def cuadrado(numero):
    return numero ** 2

numeros = [1, 2, 3, 4, 5]
resultados = map(cuadrado, numeros)
print(list(resultados))  # [1, 4, 9, 16, 25]
```

#### `filter(function, iterable)`

- **Prop贸sito**: Construye un iterador a partir de aquellos elementos de un iterable para los cuales la funci贸n devuelve verdadero.
- **Ejemplo**:

```python
def es_par(numero):
    return numero % 2 == 0

numeros = [1, 2, 3, 4, 5, 6]
resultado = filter(es_par, numeros)
print(list(resultado))  # [2, 4, 6]
```

#### `reduce(function, iterable[, initializer])`

- **Prop贸sito**: Aplica una funci贸n de dos argumentos acumulativamente a los elementos de un iterable, de izquierda a derecha, para reducir el iterable a un solo valor. `reduce()` no est谩 disponible globalmente en Python 3, se debe importar desde `functools`.
- **Ejemplo**:

```python
from functools import reduce

def sumar(a, b):
    return a + b

numeros = [1, 2, 3, 4, 5]
resultado = reduce(sumar, numeros)
print(resultado)  # 15
```

### Ventajas de las Funciones de Orden Superior

- **Composici贸n**: Facilitan la composici贸n de funciones, permitiendo crear nuevas operaciones a partir de las existentes de manera clara y concisa.
- **Reutilizaci贸n del C贸digo**: Promueven la reutilizaci贸n del c贸digo al permitir que las funciones sean utilizadas como argumentos.
- **Abstracci贸n y Expresividad**: Permiten abstracciones m谩s altas y c贸digo m谩s expresivo, especialmente en operaciones que involucran colecciones de datos.

Las funciones de orden superior son un pilar de la programaci贸n funcional, pero su utilidad no se limita a este paradigma. Son herramientas vers谩tiles que pueden mejorar significativamente la claridad, concisi贸n y expresividad del c贸digo en muchos contextos de programaci贸n. 驴Te gustar铆a explorar m谩s ejemplos o conceptos relacionados con la programaci贸n funcional?
"""

# Ejemplos 102

# Funci贸n de adaptaci贸n (adaptador o funci贸n compuesto)
def T(x): # Define c贸mo transformar un 煤nico elemento
  return x ** 2

X = [5, 7, 9, 20] # x pertenece a X

Y = list(map(T, X)) # Y = T(x) para cada x en X

print(X)
print(Y)

# Adaptador gen茅rico
def text_len(text):
  return len(text)

frutas = ["mango", "fresa", "papaya"]

frutas_tama帽o = list(map(text_len, frutas))

print(frutas)
print(frutas_tama帽o)

def F(x):
  return x >= 28 and x <= 48

X = [23, 26, 56, 43, 29, 55]

Xp = list(filter(F, X))

print(X)
print(Xp)

def R(previo, siguiente):
  return previo + siguiente

X = [67.8, 43.9, 72.5, 23.4] # 0 | 0 + 67.8, anterior + nuevo

from functools import reduce

X_suma = reduce(R, X, 0)

print(X)
print(X_suma)

"""## 103. Lambdas y expresiones generadoras

Las expresiones lambda y las expresiones generadoras son caracter铆sticas poderosas de Python que permiten escribir c贸digo m谩s conciso y eficiente, especialmente dentro del paradigma de la programaci贸n funcional.

### Lambdas

Las lambdas en Python son peque帽as funciones an贸nimas definidas mediante la palabra clave `lambda`. La sintaxis general de una lambda es:

```python
lambda argumentos: expresi贸n
```

Las lambdas pueden tener cualquier n煤mero de argumentos, pero solo una expresi贸n. La expresi贸n es evaluada y devuelta cuando se llama a la lambda. Estas funciones son 煤tiles cuando se necesita una funci贸n por un corto per铆odo de tiempo, y no se desea definirla con el est谩ndar `def`.

#### Ejemplo de Uso de Lambda

```python
# Definir una funci贸n lambda para calcular el cuadrado de un n煤mero
cuadrado = lambda x: x ** 2

print(cuadrado(5))  # Salida: 25

# Usar lambda directamente como argumento de una funci贸n de orden superior
numeros = [1, 2, 3, 4]
numeros_cuadrados = list(map(lambda x: x**2, numeros))
print(numeros_cuadrados)  # Salida: [1, 4, 9, 16]
```

### Expresiones Generadoras

Las expresiones generadoras proporcionan una manera compacta de generar secuencias de datos sin necesidad de construir una lista en memoria, lo que puede ser muy 煤til para secuencias grandes. Son similares a las comprensiones de listas pero usan par茅ntesis en lugar de corchetes, y el resultado es un generador del cual se pueden extraer elementos uno por uno.

#### Ejemplo de Uso de Expresi贸n Generadora

```python
# Crear una expresi贸n generadora para calcular los cuadrados de n煤meros del 1 al 5
cuadrados = (x**2 for x in range(1, 6))

# Acceder a los elementos del generador
for cuadrado in cuadrados:
    print(cuadrado)
# Salida: 1, 4, 9, 16, 25
```

Las expresiones generadoras son especialmente 煤tiles para operaciones que implican la transformaci贸n de datos o el filtrado de grandes conjuntos de datos, ya que no requieren que todos los elementos est茅n en memoria a la vez.

### Combinando Lambdas y Expresiones Generadoras

Lambdas y expresiones generadoras pueden ser combinadas para crear operaciones poderosas y eficientes en una sola l铆nea de c贸digo. Por ejemplo:

```python
# Filtrar y calcular el cuadrado de n煤meros pares del 1 al 10
numeros_cuadrados = (x**2 for x in range(1, 11) if x % 2 == 0)

for num in numeros_cuadrados:
    print(num)
# Salida: 4, 16, 36, 64, 100
```

Este enfoque permite construir pipelines de procesamiento de datos de manera eficiente y concisa, aprovechando lo mejor de ambos mundos: la flexibilidad de las lambdas y la eficiencia de las expresiones generadoras. 驴Hay algo m谩s sobre estos temas que te gustar铆a explorar o alg煤n otro concepto de Python avanzado?
"""

# Ejemplos 103

frutas = ["manzana", "mango", "kiwi", "lim贸n", "pera"]

frutas_tama帽os = list(map(lambda fruta: len(fruta), frutas))

print(frutas)
print(frutas_tama帽os)

frutas = ["manzana", "mango", "kiwi", "lim贸n", "pera"]

frutas_tama帽os = list(map(lambda fruta: {
    "nombre": fruta,
    "tama帽o": len(fruta),
    "inicial": fruta[0],
    "terminal": fruta[-1],
}, frutas))

print(frutas)
print(frutas_tama帽os)

print(frutas_tama帽os)

frutas_inicial_m = list(filter(lambda d: d["inicial"] == "m", frutas_tama帽os))

frutas_inicial_m

frutas_terminal_a = list(filter(lambda d: d["terminal"] == "a", frutas_tama帽os))

frutas_terminal_a

print(frutas_tama帽os)

from functools import reduce

def reduce_iniciales(iniciales, frutaInfo):
  iniciales.append(frutaInfo["inicial"] * frutaInfo["tama帽o"])
  return iniciales

reduce(reduce_iniciales, frutas_tama帽os, [])

frutas = ["mango", "pl谩tano", "pi帽a", "fresa"]

# (<result> <generador>)
# (<result> for <elemento> in <secuencia>)
# Secuencia en fr铆o (no computada hasta su consumo)
generador_frutas = (fruta for fruta in frutas)

for fruta in generador_frutas:
  print(fruta)

# Esta funci贸n genera un cliente y lo retiene hasta que se lo piden
# Cuando piden el siguiente valor en un iterador, entonces genera uno nuevo
def generador_clientes(n):
  import random

  nombres = ["Ana", "Beto", "Carlos", "Daniela", "Edwin", "Fabiola"]
  apellidos = ["Ju谩rez", "Gonz谩lez", "Mart铆nez", "Bustamante", "Hern谩ndez", "vila"]

  for i in range(n):
    cliente = {
      "nombre": random.choice(nombres),
      "apellido_paterno": random.choice(apellidos),
      "apellido_materno": random.choice(apellidos),
      "edad": random.randint(18, 99),
    }

    yield cliente

for cliente in generador_clientes(5):
  print(cliente)

"""## Ejercicios"""

from functools import reduce

# [1, 2, 3] -> "# ## ###"
# [4, 5, 2] -> "#### ##### ##"

def R(anterior, siguiente):
  print(f"Anterior: {anterior} | Siguiente: {siguiente}")
  nuevo = str(anterior + " " + "#" * siguiente).strip()
  print(f"Nuevo: {nuevo}")
  return nuevo

reduce(R, [3, 5, 2], "")

# [23, 56, 43, 22, 19] -> 56
# [98, 77, 34, 101, 22, 18] -> 101

def S(mayor, actual):
  if mayor == None:
    return actual
  if mayor > actual:
    return mayor
  else:
    return actual

reduce(S, [98, 77, 34, 101, 22, 18], None)

mayor = None

for x in [98, 77, 34, 101, 22, 18]:
  if mayor == None or mayor < x:
    mayor = x

mayor

# reduce(R<w, x>, X, w_0)
reduce(lambda mayor, x: x if mayor == None or mayor < x else mayor, [98, 77, 34, 101, 22, 18], None)

# map(T<x>, X)
list(map(lambda x: x - 50, [98, 77, 34, 101, 22, 18]))

# filter(F<x>, X)
list(filter(lambda x: x > 50, [98, 77, 34, 101, 22, 18]))

import pandas as pd

df = pd.read_csv("https://archive.ics.uci.edu/static/public/53/data.csv")

df

df["sepal length"].map(lambda x: x ** 2)