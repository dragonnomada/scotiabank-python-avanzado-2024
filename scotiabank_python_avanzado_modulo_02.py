# -*- coding: utf-8 -*-
"""scotiabank-python-avanzado-modulo-02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18xRO8gFtxLp6ArkAW9SMVlONYpJX-8gD

# Curso de Python Avanzado

<img src="https://amei.mx/wp-content/uploads/2016/08/Scotiabank-logo.jpg" alt="Scotiabank Logo" height="60">
<img src="https://www.belatrix.com/wp-content/uploads/2023/08/belatrix-logosweb-1.png" alt="Belatrix Logo" height="60">


**[Scotiabank](https://www.scotiabank.com.mx)** | **[Belatrix](https://www.belatrix.com)**

Instructor: [Alan Badillo Salas](alan@nomadacode.com)

## Bienvenida

Bienvenidos al curso de **Python Avanzado** para Scotiabank, brindado por Belatrix.

En este curso aprender谩s a desarrollar una programaci贸n avanzada con Python.

El curso est谩 dirigido a profesionales relacionados al 谩rea de desarrollo, soporte y an谩lisis de datos.

Se requieren conocimientos previos de Python Intermedio para poder cubrir satisfactoriamente este curso.

## Temario

**M贸dulo 1: Programaci贸n Funcional en Python**

1. Introducci贸n a la programaci贸n funcional
2. Funciones de orden superior
3. Lambdas y expresiones generadoras

**M贸dulo 2: Dise帽o de Patrones Avanzados**

1. Patrones de dise帽o comunes en Python
2. Aplicaci贸n pr谩ctica de patrones en el desarrollo de software

**M贸dulo 3: Manipulaci贸n Eficiente de Datos**

1. Uso avanzado de NumPy y Pandas
2. Operaciones vectorizadas y broadcasting

**M贸dulo 4: Concurrencia y Paralelismo en Python**

1. Hilos y procesos en Python
2. Multiprocessing y Asyncio

**M贸dulo 5: Optimizaci贸n de C贸digo**

1. Estrategias para mejorar el rendimiento
2. Perfilado de c贸digo y herramientas de optimizaci贸n

**M贸dulo 6: Seguridad en Desarrollo Python**

1. Principios b谩sicos de seguridad
2. Mejores pr谩cticas de codificaci贸n segura

**M贸dulo 7: Despliegue y Escalabilidad**

1. Configuraci贸n de entornos de producci贸n
2. Estrategias para escalabilidad horizontal y vertical

# Introducci贸n a la Programaci贸n Orientada a Objetos

La programaci贸n orientada a objetos (POO) es un paradigma de programaci贸n basado en el concepto de "objetos", que pueden contener datos, en forma de campos, a menudo conocidos como atributos; y c贸digo, en forma de procedimientos, a menudo conocidos como m茅todos. Python, siendo un lenguaje de programaci贸n vers谩til, soporta plenamente la programaci贸n orientada a objetos, ofreciendo una manera poderosa y flexible de organizar tu c贸digo. Aqu铆 te presento una introducci贸n a la programaci贸n orientada a objetos en Python:

### Conceptos B谩sicos de POO

- **Clases**: Una clase es un plano o prototipo a partir del cual se crean los objetos. Define un conjunto de atributos y m茅todos que caracterizan a cualquier objeto de esa clase.

- **Objetos**: Un objeto es una instancia de una clase. Un objeto en Python es una encapsulaci贸n de variables y funciones en una sola entidad. Los objetos obtienen sus variables y funciones de las clases.

- **Atributos**: Son las caracter铆sticas de la clase. Se utilizan para almacenar informaci贸n. Los atributos son variables definidas dentro de una clase.

- **M茅todos**: Son funciones definidas dentro de una clase y se utilizan para describir los comportamientos de los objetos.

### Creando una Clase en Python

Para definir una clase en Python, se utiliza la palabra clave `class` seguida del nombre de la clase y dos puntos. A continuaci贸n, se definen los m茅todos y atributos de la clase:

```python
class MiClase:
    # Constructor de la clase
    def __init__(self, atributo1, atributo2):
        self.atributo1 = atributo1
        self.atributo2 = atributo2

    # M茅todo de la clase
    def mi_metodo(self):
        print(f"Atributo 1 es {self.atributo1} y Atributo 2 es {self.atributo2}")
```

### Instanciando Objetos

Para crear un objeto (instancia de una clase), simplemente llame a la clase usando el nombre de la clase seguido de par茅ntesis, pasando los argumentos que el m茅todo constructor `__init__` espera:

```python
mi_objeto = MiClase("valor1", "valor2")
mi_objeto.mi_metodo()  # Salida: Atributo 1 es valor1 y Atributo 2 es valor2
```

### Pilares de la POO en Python

La programaci贸n orientada a objetos en Python se basa en cuatro principios fundamentales:

1. **Encapsulaci贸n**: Se refiere a la agrupaci贸n de datos (atributos) y c贸digo (m茅todos) que opera sobre los datos en una sola unidad o clase, y restringir el acceso a algunos de los componentes de un objeto.

2. **Abstracci贸n**: Permite ocultar la complejidad real de un sistema y mostrar solo lo necesario al exterior. Se logra mediante clases abstractas e interfaces.

3. **Herencia**: Permite a una clase heredar atributos y m茅todos de otra, facilitando la reutilizaci贸n de c贸digo y la creaci贸n de relaciones jer谩rquicas entre clases.

4. **Polimorfismo**: Significa la capacidad de una entidad (m茅todo o objeto) de referirse a instancias de diferentes clases. Python permite el polimorfismo, permitiendo que un mismo m茅todo funcione de manera diferente en funci贸n del objeto que lo invoca.

### Conclusi贸n

La programaci贸n orientada a objetos en Python es un paradigma poderoso que facilita la escritura de c贸digo organizado, reutilizable y f谩cil de mantener. Al dominar la POO, podr谩s dise帽ar soluciones m谩s eficientes y efectivas para tus problemas de programaci贸n.
"""

class Producto:
  def __init__(self, nombre, precio):
    #print(f"Voy a construir un objeto a partir de nombre={nombre} precio=${precio}")
    self.nombre = nombre
    self.precio = precio
    self.iva = precio * 0.16
    self.precio_con_iva = precio + self.iva

  def describir(self):
    print("{:<20} ${:>6.2f} (IVA ${:>6.2f}) | ${:>6.2f}".format(self.nombre, self.precio, self.iva, self.precio_con_iva))

producto1 = Producto("Coca-Cola", 30.5) # producto1 -> objeto | Producto -> clase | Producto() -> instanciaci贸n (llamar al m茅todo de construcci贸n "__init__")

print(producto1)
print(producto1.nombre, type(producto1.nombre))
print(producto1.precio, type(producto1.precio))
print(producto1.iva, type(producto1.iva))
print(producto1.precio_con_iva, type(producto1.precio_con_iva))

producto1.describir()

import random

for i in range(10):
  producto_i = Producto(f"Producto {i + 1}", random.uniform(1, 100))
  producto_i.describir()

class Carrito:
  def __init__(self):
    self.productos = []

  def agregarProducto(self, producto):
    self.productos.append(producto)

  def calcularTotal(self):
    from functools import reduce
    return reduce(lambda total, producto: total + producto.precio, self.productos, 0.0)

  def calcularTotalIva(self):
    from functools import reduce
    return reduce(lambda total, producto: total + producto.iva, self.productos, 0.0)

  def calcularTotalConIva(self):
    from functools import reduce
    return reduce(lambda total, producto: total + producto.precio_con_iva, self.productos, 0.0)

  def describir(self):
    print("Carrito de compras | Total de productos ({})".format(len(self.productos)))
    print("-" * 54)
    if len(self.productos) > 0:
      for producto in self.productos:
        producto.describir()
      print("-" * 54)
      total = self.calcularTotal()
      total_iva = self.calcularTotalIva()
      total_con_iva = self.calcularTotalConIva()
      print("Total {} ${:>6.2f} (IVA ${:>6.2f}) | ${:6.2f}".format(" " * 14, total, total_iva, total_con_iva))
    else:
      print("  El carrito est谩 vac铆o ゲ")
    print("-" * 54)
    print()

carrito1 = Carrito() # self.productos = []

carrito1.describir()

carrito1.agregarProducto(Producto("Coca-Cola 600ml", 17.5))
carrito1.agregarProducto(Producto("Pesi 600ml", 16.5))
carrito1.agregarProducto(Producto("Gansito", 21.5))

carrito1.describir()

"""# M贸dulo 2: Dise帽o de Patrones Avanzados

1. Patrones de dise帽o comunes en Python
2. Aplicaci贸n pr谩ctica de patrones en el desarrollo de software

## 201. Patrones de dise帽o comunes en Python

Los patrones de dise帽o son soluciones generales y reutilizables para los problemas comunes que nos encontramos en el dise帽o de software. No son plantillas que se puedan traducir directamente en c贸digo, sino m谩s bien directrices para abordar ciertos problemas en contextos espec铆ficos. En Python, al igual que en otros lenguajes de programaci贸n, los patrones de dise帽o pueden clasificarse en tres tipos principales: creacionales, estructurales y de comportamiento.

### Patrones Creacionales
Se enfocan en c贸mo se crean las instancias de objetos. Simplifican la creaci贸n de objetos cuando existen complejidades involucradas.

1. **Singleton**: Asegura que una clase tenga una 煤nica instancia y proporciona un punto de acceso global a esa instancia. En Python, se puede implementar mediante una clase base o decoradores. Es 煤til manejar recursos compartidos, como una conexi贸n a una base de datos.
   
2. **Factory Method**: Define una interfaz para crear un objeto, pero deja que las subclases decidan qu茅 clase instanciar. Facilita la extensi贸n del c贸digo existente y es 煤til en entornos colaborativos para definir y expandir tipos de objetos procesados.

3. **Builder**: Separa la construcci贸n de un objeto complejo de su representaci贸n, permitiendo que el mismo proceso de construcci贸n cree diferentes representaciones. Esto es particularmente 煤til para crear configuraciones complejas de experimentos o visualizaciones de datos de forma ordenada.

### Patrones Estructurales
Tratan sobre c贸mo se componen las clases y objetos para formar estructuras m谩s grandes.

1. **Adapter (Adaptador)**: Permite que interfaces incompatibles trabajen juntas. Esto es 煤til cuando se utilizan bibliotecas o APIs que tienen interfaces distintas de las que el c贸digo existente espera.

2. **Decorator**: Adjunta responsabilidades adicionales a un objeto de manera din谩mica. Los decoradores ofrecen una alternativa flexible a la subclase para extender la funcionalidad, muy 煤til en Python para a帽adir funcionalidades en tiempo de ejecuci贸n, como logging o manejo de errores en funciones espec铆ficas.

3. **Proxy**: Proporciona un sustituto o marcador de posici贸n para otro objeto para controlar el acceso a 茅l. til para controlar el acceso a recursos que pueden ser costosos de crear.

### Patrones de Comportamiento
Se centran en la comunicaci贸n efectiva y la asignaci贸n de responsabilidades entre objetos.

1. **Observer**: Define una dependencia de uno-a-muchos entre objetos de manera que cuando un objeto cambia de estado, todos sus dependientes son notificados y actualizados autom谩ticamente. Muy 煤til para implementar dashboards din谩micos o visualizaciones que se actualizan en respuesta a cambios de datos.

2. **Strategy**: Define una familia de algoritmos, encapsula cada uno de ellos, y los hace intercambiables. La estrategia permite que el algoritmo var铆e independientemente de los clientes que lo utilizan. Esto es beneficioso para alternar entre diferentes algoritmos de procesamiento de datos o m茅todos de an谩lisis sin cambiar el c贸digo cliente.

3. **Command**: Encapsula una solicitud como un objeto, permitiendo parametrizar clientes con colas, solicitudes y operaciones. Puede ser utilizado para implementar operaciones deshacer/rehacer o para programar tareas que pueden ser ejecutadas en diferentes momentos.

Estos patrones no solo ayudan a escribir c贸digo m谩s limpio y mantenible sino que tambi茅n facilitan la colaboraci贸n, donde m煤ltiples usuarios pueden estar trabajando en el mismo proyecto. Implementar estos patrones correctamente puede llevar a una mejor organizaci贸n del c贸digo, mayor reutilizaci贸n y una integraci贸n m谩s f谩cil de nuevas caracter铆sticas o bibliotecas.
"""

# Ejemplo del Singlet贸n

class DataSource:
  def __init__(self, token):
    if token != "123":
      raise Exception("Esta clase requiere un token v谩lido para ser instancia")
    self.data = []

  def addPoint(self, point):
    self.data.append(point)

  def describe(self):
    print(f"Points ({len(self.data)})")
    for point in self.data:
      print(point)

class DataSourceSingleton:
  shared = DataSource("123")

DataSourceSingleton.shared.addPoint({ "x": 123, "y": 456 })
DataSourceSingleton.shared.addPoint({ "x": 344, "y": 657 })
DataSourceSingleton.shared.addPoint({ "x": 563, "y": 111 })
DataSourceSingleton.shared.addPoint({ "x": 243, "y": 223 })
DataSourceSingleton.shared.addPoint({ "x": 987, "y": 143 })
DataSourceSingleton.shared.addPoint({ "x": 143, "y": 998 })

DataSourceSingleton.shared.describe()

ds = DataSource("???")

# Ejemplo de Factory Method (M茅todos de F谩brica)

class SaludarEspa帽ol:

  def __init__(self, nombre):
    self.nombre = nombre

  def saludar(self):
    print(f"Hola {self.nombre} ")

class SaludarIngles:

  def __init__(self, fecha, veces):
    self.fecha = fecha
    self.veces = veces

  def saludar(self):
    for i in range(self.veces):
      print(f"[{self.fecha}] Hello world ")

class SaludarRobot:

  def __init__(self, marca, modelo):
    self.marca = marca
    self.modelo = modelo

  def saludar(self):
    print(f"[{self.marca} / {self.modelo}] Pipu pipu ")

class Saludador:

  def crearSaludoEspa帽ol(self, nombre):
    self.instance = SaludarEspa帽ol(nombre)
    return self

  def crearSaludoIngles(self, fecha, veces):
    self.instance = SaludarIngles(fecha, veces)
    return self

  def crearSaludoRobot(self, marca, modelo):
    self.instance = SaludarRobot(marca, modelo)
    return self

saludador = Saludador().crearSaludoEspa帽ol("Beto")

saludador.instance.saludar()

saludador = Saludador().crearSaludoIngles("9th, april 2024", 4)

saludador.instance.saludar()

saludador = Saludador().crearSaludoRobot("Tesla", "Tux")

saludador.instance.saludar()

# Ejemplo de Builder (Constructor por partes)

class TerminalVenta:

  def __init__(self, id):
    self.id = id
    self.iniciada = False

  def setVendedor(self, vendedor):
    if not vendedor.activo:
      raise Exception("El vendedor no est谩 activo")
    self.vendedor = vendedor

  def iniciar(self):
    import random
    self.sesionId = random.randint(10_000, 1_000_000)
    self.iniciada = True

  def cobrar(self):
    if not self.iniciada:
      raise Exception("La terminal no est谩 iniciada")

    print(f"La terminal {self.id} ha iniciado el proceso de cobro con el vendedor {self.vendedor.nombre}")

class Vendedor:

  def __init__(self, id, nombre, activo):
    self.id = id
    self.nombre = nombre
    self.activo = activo

# terminal1 = TerminalVenta(123)
# terminal1.cobrar() # ERROR: La terminal no est谩 iniciada

vendedores = [
    Vendedor(1001, "Juan P茅rez", True),
    Vendedor(1002, "John Poe", False),
    Vendedor(1003, "Jorge Jim茅nez", True),
    Vendedor(1004, "Paty Ramp铆rez", True),
]

def crearTerminalVenta(terminalVentaId, vendedorId):
  # 1. Crea la terminal con el terminalVentaId
  terminal = TerminalVenta(terminalVentaId)

  # 2. Ajusta el vendedor
  # Buscar el vendedor
  from functools import reduce
  vendedor = reduce(lambda encontrado, vendedor: vendedor if vendedor.id == vendedorId else encontrado, vendedores, None)

  if vendedor == None:
    raise Exception(f"El vendedor con id {vendedorId} no existe")

  terminal.setVendedor(vendedor)

  # 3. Iniciamos la terminal
  terminal.iniciar()

  return terminal

terminal = crearTerminalVenta(34, 1004)

terminal.cobrar()

# Ejemplo de Observador

class ObservadorCarrito:

  def __init__(self):
    self.listeners = [] # son funciones que reciben los eventos

  def addListener(self, listener):
    self.listeners.append(listener)

  def onProductosChange(self, producto, productos): # Renotifica a los listeners ("suscriptores")
    for listener in self.listeners:
      # El evento envia un diccionario con los datos del evento
      listener({ "event": "productoChange", "data": (producto, productos) })

class Carrito(ObservadorCarrito): # --> HERENCIA

  def __init__(self):
    ObservadorCarrito.__init__(self) # LLAMADA AL CONSTRUCTOR SUPERIOR
    self.productos = []

  def agregarProducto(self, producto):
    self.productos.append(producto)
    self.onProductosChange(producto, self.productos) # desencadena el evento ("notificaci贸n al padre")

  def quitarProducto(self, producto):
    producto = self.productos.remove(producto)
    self.onProductosChange(producto, self.productos) # desencadena el evento ("notificaci贸n al padre")

carrito1 = Carrito()

total = 0

def updateTotal(evento):
  global total
  if evento["event"] == "productoChange":
    producto, productos = evento["data"]
    from functools import reduce
    total = reduce(lambda total, producto: total + producto.precio, productos, 0.0)
  print(f"El total ha sido actualizado: {total}")

def tieneCocaCola(evento):
  if evento["event"] == "productoChange":
    producto, productos = evento["data"]

    encontrada = False

    for producto in productos:
      if producto.nombre == "Coca-Cola":
        encontrada = True

    if encontrada:
      print("Hay una Coca-Cola dentro de los productos")
    else:
      print("No hay una Coca-Cola dentro de los productos")

carrito1.addListener(updateTotal)
carrito1.addListener(tieneCocaCola)

cocaCola = Producto("Coca-Cola", 100)

carrito1.agregarProducto(cocaCola)
carrito1.agregarProducto(Producto("Pepsi", 200))
carrito1.agregarProducto(Producto("Galletar Mar铆as", 500))
carrito1.quitarProducto(cocaCola)

print(total)

"""## 202. Aplicaci贸n pr谩ctica de patrones en el desarrollo de software

---


"""

# Sistema de Venta de Frutas

# 1. Definir las clase Fruta y CanastaFrutas

class Fruta:
  def __init__(self, id, nombre, precio):
    self.id = id
    self.nombre = nombre
    self.precio = precio

  def describir(self):
    ...

class CanastaFrutas:

  def __init__(self):
    self.frutas = []

  def agregarFruta(self, id, nombre, precio):
    self.frutas.append(Fruta(id, nombre, precio))

  def quitarFruta(self, id):
    for index, fruta in enumerate(self.frutas):
      if fruta.id == id:
        self.frutas.pop(index)
        return
    raise Exception(f"La fruta con id {id} no existe")

# > Realiza unas pruebas y calcula los totales

# 2. Definir el ObservadorCansataFrutas

# > Observa cuando se agrega una fruta
# > Observa cuando se quita una fruta

# 3. Redefinir la CanastaFrutas y adaptar el ObservadorCansataFrutas